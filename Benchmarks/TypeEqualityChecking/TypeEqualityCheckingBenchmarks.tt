<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//	This code was generated from the "TypeEqualityCheckingBenchmarks.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------
<#

(string A, string B)[] trueChecks = 
{
	("string", "string"),
	("int", "int"),
	("double", "double"),
	("decimal", "decimal"),
	("byte", "byte"),
	("short", "short"),
};

(string A, string B)[] falseChecks = 
{
	("string", "int"),
	("int", "string"),
	("double", "int"),
	("decimal", "int"),
	("byte", "int"),
	("short", "int"),
};

#>

using BenchmarkDotNet.Attributes;
using System.Runtime.CompilerServices;
using System;

namespace TypeEqualityChecking
{
	public class TypeEqualityCheckingBenchmarks
	{
		bool temp;

		[Benchmark]
		public void TypeOfEquals()
		{
			// true checks
<# foreach (var (A, B) in trueChecks) { #>
			temp = typeof(<#= A #>) == typeof(<#= B #>);
<# } #>

			// false checks
<# foreach (var (A, B) in falseChecks) { #>
			temp = typeof(<#= A #>) == typeof(<#= B #>);
<# } #>
		}

		static bool TypeOfEqualsGeneric<A, B>() => typeof(A) == typeof(B);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		static bool TypeOfEqualsGenericInlined<A, B>() => typeof(A) == typeof(B);

		[Benchmark]
		public void TypeOfEqualsGeneric()
		{
			// true checks
<# foreach (var (A, B) in trueChecks) { #>
			temp = TypeOfEqualsGeneric<<#= A #>, <#= B #>>();
<# } #>

			// false checks
<# foreach (var (A, B) in falseChecks) { #>
			temp = TypeOfEqualsGeneric<<#= A #>, <#= B #>>();
<# } #>
		}

		[Benchmark]
		public void TypeOfEqualsGenericInlined()
		{
			// true checks
<# foreach (var (A, B) in trueChecks) { #>
			temp = TypeOfEqualsGenericInlined<<#= A #>, <#= B #>>();
<# } #>

			// false checks
<# foreach (var (A, B) in falseChecks) { #>
			temp = TypeOfEqualsGenericInlined<<#= A #>, <#= B #>>();
<# } #>
		}

		struct Operator_is_struct<A, B> { }
		static bool Operator_is<A, B>() => default(Operator_is_struct<A, B>) is Operator_is_struct<A, A>;

		[Benchmark]
		public void StructWrappedIs()
		{
			// true checks
<# foreach (var (A, B) in trueChecks) { #>
			temp = Operator_is<<#= A #>, <#= B #>>();
<# } #>

			// false checks
<# foreach (var (A, B) in falseChecks) { #>
			temp = Operator_is<<#= A #>, <#= B #>>();
<# } #>
		}

		public static class Cache<A, B>
		{
			public static bool Equal = typeof(A) == typeof(B);
		}

		[Benchmark]
		public void CachedTypeEquality()
		{
			// true checks
<# foreach (var (A, B) in trueChecks) { #>
			temp = Cache<<#= A #>, <#= B #>>.Equal;
<# } #>

			// false checks
<# foreach (var (A, B) in falseChecks) { #>
			temp = Cache<<#= A #>, <#= B #>>.Equal;
<# } #>
		}
	}
}
